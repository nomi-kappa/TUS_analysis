---
title: "GNG_TUS_Study_1_320trials_preprocessing"
author: "nomi"
date: "2023-10-31"
output: html_document
---

 

# LOAD LIBRARIES
```{r}
#library(Rccp)
#library(rlang)
library(tibbletime)
library(purrr)
library(stringr)
library(report)
#library(ggplot)
library(ggplot2)
library(dplyr)
#library(lmer)
library(tidyverse)
library(patchwork)
library(ggpubr)
library(jtools) #for explanation of lmer
library(yarr)
library (yarrr)
library(afex)
#install.packages("devtools")
#devtools::install_github("mikabr/ggpirate")
#library(ggpirate)
#p_load ( rms, htmltools, bridgesampling, rstanarm, magrittr, scales, RColorBrewer, 
# parsnip, zoo, wesanderson, yarr, BiocManager, afex, GGally, lmerTest, aod, splines)
```



    #PREPROCESSING

## insert .txt files
```{r}
a.sham<- tibble(filename = list.files("1.SHAM", "*.txt", full.names=TRUE)) %>% 
    group_by(filename) %>% 
    do(read.table(.$filename))
c.ai<- tibble(filename = list.files("3.AI", "*.txt", full.names=TRUE)) %>% 
    group_by(filename) %>% 
    do(read.table(.$filename))
b.dacc<- tibble(filename = list.files("2.dACC", "*.txt", full.names=TRUE)) %>% 
    group_by(filename) %>% 
    do(read.table(.$filename))
```

## add condition column
```{r}
a.sham <- a.sham %>%
      mutate (condition="a.sham")
c.ai <- c.ai %>%
      mutate (condition="c.ai")
b.dacc <- b.dacc %>%
      mutate (condition="b.dacc")
```

## Set variable names
```{r}
a.sham <- a.sham %>% set_names(c("ID", "stim_ID", "GW", "GAL", "NGW", "NGL", "jitter1", 
              "jitter2", "RT", "outcomefeed", "condition"))
b.dacc <- b.dacc %>% set_names(c("ID", "stim_ID", "GW", "GAL", "NGW", "NGL", "jitter1", 
              "jitter2", "RT", "outcomefeed", "condition"))
c.ai <- c.ai %>% set_names(c("ID", "stim_ID", "GW", "GAL", "NGW", "NGL", "jitter1", 
              "jitter2", "RT", "outcomefeed", "condition"))
```


## combine datasets
```{r}
tus <-bind_rows(a.sham, c.ai, b.dacc)

```


## add session column
```{r}
# Extract numbers at the end of each level and create a new column
tus<-tus %>%
  mutate(session = as.factor(str_extract(ID,"(?<=\\D)\\d+(?=_log.txt)")))
#View(tus)
```


## Change name of ID rows to match the subj_ID (i.e.  "pilot data/DBGE0324_log.txt" --> "DBGE0324")
```{r}
tus <- tus %>%
      mutate_at("ID", str_replace, "1.SHAM/", "")# & "log.txt", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "3.AI/", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "2.dACC/", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_SHAM_2", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_SHAM_3", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_SHAM_1", "")
#tus <- tus %>%
   #   mutate_at("ID", str_replace, "_SHAM__1", "_sham")
tus <- tus %>%
      mutate_at("ID", str_replace, "_dACC_2", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_dACC_3", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_dACC_1", "")
#tus <- tus %>%
    #  mutate_at("ID", str_replace, "_ACC_2", "_dACC")
#tus <- tus %>%
#      mutate_at("ID", str_replace, "_ACC_1", "_dACC")
tus <- tus %>%
      mutate_at("ID", str_replace, "_AI_2", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_AI_3", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_AI_1", "")
tus <- tus %>%
      mutate_at("ID", str_replace, "_log.txt", "")
#tus <- tus %>%
  #    mutate_at("ID", str_replace, "SINB_0180", "SINB0180")
#copied
#tus <- tus %>%
   #   mutate_at("ID", str_replace, "_Copy", "")


# Rename ID
tus <- tus %>%
  mutate(ID = ifelse(ID == "SSCH0384", "SSCF0384", ID))

```

## Add response col (press - no_press)
```{r}
tus$response <- with(tus, ifelse(RT>0, "press", "no_press"))
tus$GoResponse <- with(tus, ifelse(RT>0, 1, 0)) 
```

## Add Cue column (if stim_ID=NGW then NGW, etc. for  NGL, GW, GAL)
```{r}
tus$Cue <- ifelse(tus$stim_ID == tus$NGL, 'NGL',
                ifelse(tus$stim_ID == tus$NGW, 'NGW', 
                ifelse(tus$stim_ID == tus$GW, 'GW', 
              ifelse(tus$stim_ID == tus$GAL, 'GAL', NA))))
    ```

## Add GNG col (Go-noGO)
```{r}
tus$req_action <- ifelse(tus$stim_ID == tus$NGL, 'noGo',
                ifelse(tus$stim_ID == tus$NGW, 'noGo', 'Go'))   
#NB's way: 
#pilot$ReqAction <- ifelse(pilot$Cue == 'NGL', 'NoGo',
            #       ifelse(pilot$Cue == 'NGW', 'NoGo',
             #      ifelse(pilot$Cue == 'GW', 'Go',
              #      felse(pilot$Cue == 'GAL', 'Go', NA))))

```
 
## Add correct column (0-1)  
```{r}
tus <- tus %>%
  mutate(correct = ifelse(req_action == "noGo", ifelse(response == "no_press", 1, 0), 
         
                    ifelse(req_action == "Go", ifelse(response == "press", 1, 0), 1)))
```
        
## Trial column 
```{r}
#1,2,3...100...320
tus <- tus %>%
  group_by(ID, condition) %>%
  mutate(trial_number = row_number())
```


## block colums 1, 2, 3, 4   =====sos with the trials that have 400 instead of 320
```{r}
tus$block <- ifelse(tus$trial_number == 1:80, '1',
                ifelse(tus$trial_number == 81:160, '2', 
                ifelse(tus$trial_number == 161:240, '3', 
              ifelse(tus$trial_number == 241:320, '4', NA))))
# counts trials of the same condition within each block
count_trials <- rollify(function(x) sum(last(x) == x), window=80)#turns a function 
#into a rolling version of itself for use inside of a call to dplyr::mutate() ,
# however it works equally as well when called from purrr::map()
```

## trial_count column
```{r}
tus <- tus %>%
  group_by(ID, block, condition) %>%
  mutate(TrialCount = count_trials(Cue)) %>%
  group_by(ID, block,condition, Cue) %>%
  mutate(TrialCount = ifelse(is.na(TrialCount), row_number(ID), TrialCount))
```


## Add win_lose column (win - lose) 
```{r}
tus$feedback <- recode_factor(tus$outcomefeed, "-1" = "lose", 
                                "1" = "win", "0"= "neutral")

```
      
## Add Win/Avoid condition column (if stim_ID=NGW then NGW, etc. for  NGL, GW, GAL)
```{r}
tus$OutValence <- ifelse(tus$Cue == 'NGL', 'Avoid',
                   ifelse(tus$Cue == 'NGW', 'Win',
                   ifelse(tus$Cue == 'GW', 'Win',
                   ifelse(tus$Cue == 'GAL', 'Avoid', NA))))
```

## Add salient feedback column only
```{r}
tus <- tus %>%
  mutate(salient = ifelse(feedback == "win","win",
                      ifelse(feedback == "lose", "lose", NA)))
```
    
        #'followup_beha' showing response after feedback + 1 in trial_number
#behaviour after loss and after winning feedback. Adding a column based on feedback 
showing what response/behaviour they have chosen, go or noGo (press or no_press). Maybe something like
for feedback [i], mutate column [followup_beha] showing response after feedback +1 in trial_number,
grouping by ID and condition.
```{r}

# Convert feedback column to a factor (if it's not already a factor)
tus$feedback <- as.factor(tus$feedback)

# Mutate column 'followup_beha' showing response after feedback + 1 in trial_number
tus <- tus %>%
  group_by(ID, condition, Cue, req_action) %>%
  mutate(followup_beha = lead(response, order_by = trial_number, default = NA))

# Count the number of occurrences for each level of the Cue column, to check is balanced
 cue_counts <- table(tus$Cue);print(cue_counts); View(tus)
 
 
 
 # Recode followup_beha as binary (0 for "no_press" and 1 for "press")
tus$followup_beha_binary <- as.numeric(tus$followup_beha == "press")

# Check the recoded variable
table(tus$followup_beha_binary)
```


              # whether they are correct after a correct feedback
              Find the follow up behaviour after receiving the correct feedback (or whether they were correct after receiving the correct feedback 80% and not the 20%)

correct feedback
  when NGL and response:no_press and  feedback neutral, then 1 else 0 =>  add to column -> correct_feedback 
  when GW and response: press and and feedback win, then 1, else 0 =>  add to column -> correct_feedback
  when GAL and response press and and feedback neutral, then 1, else 0=>  add tocolumn ->correct_feedback
  when NGW and response no_press and feedback  win, then 1, else 0 =>  add to column ->correct_feedback
  how to find the follow-up behaviour. Create a column called correct_proba_feed
  
  
following correct action (whether they were correct after receiving the correct feedback 80% and not the 20%)

!!!!!!!!!!!!!!!!!! NEUTRAL is ALSO correct when NGL and GAL and they get 0 and feedback was 0
  
  
```{r}
# Step 1: Calculate correct_feedback based on specified conditions (check in which instanses feedback was correct 80%) - all good!
tus <- tus %>%
  mutate(correct_feedback = case_when(
    is.na(Cue) ~ NA_real_,  # If Cue is NA, assign NA to correct_feedback
    Cue == "NGL" & response == "no_press" & feedback == "neutral" ~ 1,
    Cue == "GW" & response == "press" & feedback == "win" ~ 1,
    Cue == "GAL" & response == "press" & feedback == "neutral" ~ 1,
    Cue == "NGW"  & response == "no_press"& feedback == "win" ~ 1,
    Cue == "NGL" & response == "press" & feedback == "lose" ~ 1,
    Cue == "GW" & response == "no_press" & feedback == "neutral" ~ 1,
    Cue == "GAL" & response == "no_press" & feedback == "lose" ~ 1,
    Cue == "NGW"  & response == "press"& feedback == "neutral" ~ 1,
    TRUE ~ 0
  ))

        #check percentages and if 80% 20%
        table(tus$feedback)
        table(tus$correct_feedback)

                    
total_count <- 26240
count_0s <- 4904
count_1s <- 21156
count_lose <- 3910
count_win <- 8503
count_nutral <- 13647

      # Calculate proportions 
          count_0s <- count_0s / total_count; print(count_0s)
                count_1s <- count_1s / total_count; print (count_1s)

        # Step 2: Calculate followup_response after correct feedback   -called:followup_correctfeed
      # Add a column indicating follow-up response after correct feedback but also indicate response after wrong_feedback_20%

tus <- tus %>%
  mutate(followup_correctfeed = case_when(
    correct_feedback == 1 ~ lead(response, order_by = trial_number, default = "wrong_feed_20%"),
    TRUE ~ "wrong_feed_20%"  # For rows where correct_feedback is not 1, set followup_response as "wrong_feed_20%" (20% where wrong feedback is given - opposite than expected)
  ))

    #Add column to show what behaviour/action they followed after wrong feedback is given
tus <- tus %>%
  mutate(followup_wrong_feed = case_when(
    correct_feedback == 0 ~ lead(response, order_by = trial_number, default = "correct_feedback"),
    TRUE ~ "correct_feedback"
  ))


# Calculate the percentage of instances of "wrong_feed_20%" in followup_correctfeed column
wrong_feedback_percentage <- mean(tus$followup_correctfeed == "wrong_feed_20%") * 100

wrong_feedback_percentage # 20.37 ! perfect




# Recode followup_correctfeed as trinary (0 for "no_press", 1 for "press", 2 for "wrong_feed_20%")
tus$followup_correctfeed_trinary <- ifelse(tus$followup_correctfeed == "press", 1,
                                           ifelse(tus$followup_correctfeed == "no_press", 0, 2))

# Check the recoded variable
table(tus$followup_correctfeed_trinary)


```

          #Actual reward, excluding wrong feedback (20%) column - called: actual_reward
          FOR GW & NGW: correctfeedback == 1 & feedback == win & correct ==1 then "reward"
          FOR GW & NGW: correctfeedback == 1 & feedback == neutral & correct ==0 then "no_reward"
          FOR NGL & GAL: correctfeedback == 1 & feedback == lose & correct ==0 then "punishment"
          FOR NGL & GAL: correctfeedback == 1 & feedback == neutral & correct ==1 then "no_punishment"
          
          #Reward in general column - called: reward
          Valence == Win & feedback == win, then "reward"
          Valence == Win & feedback == neutral, then "no_reward"          
          Valence == lose & feedback == neutral, then "no_punishment"
          Valence == lose & feedback == lose, then "punishment"

          
```{r}
# actual_reward 
tus$actual_reward <- NA  # Initialize the column with NA values

# Define conditions for actual_reward column
tus$actual_reward[tus$Cue %in% c("GW", "NGW") & tus$correct_feedback == 1 & tus$feedback == "win" & tus$correct == 1] <- "reward"
tus$actual_reward[tus$Cue %in% c("GW", "NGW") & tus$correct_feedback == 1 & tus$feedback == "neutral" & tus$correct == 0] <- "no_reward"
tus$actual_reward[tus$Cue %in% c("NGL", "GAL") & tus$correct_feedback == 1 & tus$feedback == "lose" & tus$correct == 0] <- "punishment"
tus$actual_reward[tus$Cue %in% c("NGL", "GAL") & tus$correct_feedback == 1 & tus$feedback == "neutral" & tus$correct == 1] <- "no_punishment"

# reward 
tus$reward <- NA  # Initialize the column with NA values

# Define conditions for reward column
tus$reward[tus$OutValence == "Win" & tus$feedback == "win"] <- "reward"
tus$reward[tus$OutValence == "Win" & tus$feedback == "neutral"] <- "no_reward"
tus$reward[tus$OutValence == "Avoid" & tus$feedback == "neutral"] <- "no_punishment"
tus$reward[tus$OutValence == "Avoid" & tus$feedback == "lose"] <- "punishment"

```
          
          #behaviour following reward
```{r}
# Mutate column 'followup_beha_reward' showing response after reward based on groupings
tus <- tus %>%
  group_by(ID, condition, Cue, req_action, reward) %>%
  mutate(followup_beha_reward = lead(response, order_by = trial_number + 1, default = NA))

```
          

#Exlusion 3SDs still 30 participants
```{r}
# Calculate mean accuracy per participant
mean_accuracy_per_participant <- tus %>%
  group_by(ID) %>%
  summarise(mean_accuracy = mean(correct, na.rm = TRUE))

# Calculate mean and standard deviation of mean accuracy
mean_accuracy <- mean(mean_accuracy_per_participant$mean_accuracy)
sd_accuracy <- sd(mean_accuracy_per_participant$mean_accuracy)

# Define lower and upper bounds
lower_bound <- mean_accuracy - 3 * sd_accuracy
upper_bound <- mean_accuracy + 3 * sd_accuracy

# Identify excluded participants
excluded_participants <- mean_accuracy_per_participant %>%
  filter(mean_accuracy < lower_bound | mean_accuracy > upper_bound)

# Add a column to indicate exclusion
mean_accuracy_per_participant <- mean_accuracy_per_participant %>%
  mutate(excluded = ifelse(ID %in% excluded_participants$ID, "Excluded", "Included"))

# Merge exclusion information back into tus dataset
tus <- left_join(tus, mean_accuracy_per_participant, by = "ID")

# Print number of participants before and after exclusion
num_participants_before <- nrow(mean_accuracy_per_participant)
num_participants_after <- num_participants_before - nrow(excluded_participants)

cat("Number of participants before exclusion:", num_participants_before, "\n")
cat("Number of participants after exclusion:", num_participants_after, "\n")

# View the updated tus dataset
View(tus)


```

# Exclusion 3sd per condition and ID
```{r}
# Define function to filter data within ±3 standard deviations
filter_within_3sds <- function(x) {
  mean_x <- mean(x)
  sd_x <- sd(x)
  lower_bound <- mean_x - 3 * sd_x
  upper_bound <- mean_x + 3 * sd_x
  return(x >= lower_bound & x <= upper_bound)
}

# Filter data within ±3 standard deviations per ID and per condition
filtered_tus <- tus %>%
  group_by(ID, condition) %>%
  filter(filter_within_3sds(RT))

# Identify excluded participants per condition
excluded_participants_per_condition <- filtered_tus %>%
  group_by(ID, condition) %>%
  summarise(excluded = ifelse(n() == 0, "Excluded", "Included"))

# Merge exclusion information back into the original dataset
tus <- left_join(tus, excluded_participants_per_condition, by = c("ID", "condition"))

# Print number of participants before and after exclusion per condition
num_participants_before_per_condition <- tus %>%
  distinct(ID, condition) %>%
  summarise(num_participants = n()) %>%
  nrow()

num_participants_after_per_condition <- excluded_participants_per_condition %>%
  filter(excluded == "Included") %>%
  distinct(ID, condition) %>%
  summarise(num_participants = n()) %>%
  nrow()

cat("Number of participants before exclusion per condition:", num_participants_before_per_condition, "\n")
cat("Number of participants after exclusion per condition:", num_participants_after_per_condition, "\n")

#pr


# Print conditions per ID before exclusion
conditions_per_ID_before <- tus %>%
  filter(!is.na(correct)) %>%
  distinct(ID, condition) %>%
  arrange(ID)  # Sort by ID for clarity

print("Conditions per ID before exclusion:")
print(conditions_per_ID_before)

# Print conditions per ID after exclusion
conditions_per_ID_after <- filtered_tus %>%
  distinct(ID, condition) %>%
  arrange(ID)  # Sort by ID for clarity

print("Conditions per ID after exclusion:")
print(conditions_per_ID_after)

# Count conditions per ID before exclusion
conditions_count_before <- tus %>%
  filter(!is.na(correct)) %>%
  group_by(ID) %>%
  summarise(num_conditions = n_distinct(condition)) %>%
  arrange(ID)  # Sort by ID for clarity

print("Conditions count per ID before exclusion:")
View(conditions_count_before)

# Count conditions per ID after exclusion
conditions_count_after <- filtered_tus %>%
  group_by(ID) %>%
  summarise(num_conditions = n_distinct(condition)) %>%
  arrange(ID)  # Sort by ID for clarity

print("Conditions count per ID after exclusion:")
View(conditions_count_after)


```

 ##write.csv
```{r}
write.csv(tus, "GNG_TUS_S1.csv")
```



