---
  title: "Inverse Efficiency Score Analysis"
author: "Nad√®ge B."
date: "2024-07-31"
output:
  html_document: default
---
  
# Load libraries and custom functions
```{r include=FALSE}
library(ggplot2)
library (yarrr)
library(tidyverse)
library(forcats)
```

# READ FILES
```{r include=FALSE}
tus <- read_csv("GNG_TUS_S1.csv")
tus_filtered <- read_csv ("GNG_tus_filtered_S1.csv")

tus_filtered$Condition <- forcats::fct_rev(tus_filtered$condition)

```

# IES (Inverse Efficiency Score) for Studying Speed-Accuracy Performance
- the lowest the IES the better the performance

Formula:
  IES = RT/1 - PE (proportion of errors) OR
IES = RT/PC (proportion of correct responses)

see https://psychologicabelgica.com/articles/10.5334/pb-51-1-5
1. so I need to find the proportion of correct responses first per participant, Cue, condition
2. compute the mean (or median) RT per participant, Cue, condition
3. calculate their IES

Note that the IES attempt to capture some kind of speed accuracy trade off. The applies to stadanrd go/nogo tasks but it's not as relevant in RL tasks, since the choosing the non-advantageous option is not necessarily an error, it's part of the learning process to accumulate evident relative to the value of each option. Besides, in this task, the 'correct' response is a no-press, hence is not associated ith a RT, for half of the cues.

#A. Calculate the IES for each row:
```{r}
# Calculate proportion of correct responses
# NB: you cannot compute a proportion for a single trial. You first need to compute the proportion of correct response per participant & cue

# Summarize by condition
IES_by_cond_cue_id<- tus_filtered %>%
  group_by(ID, Condition, req_action, OutValence, Cue) %>%
  summarise(
    prop_correct = mean(correct, na.rm = TRUE),
    meanRT = mean(RT, na.rm = TRUE),
    IES = meanRT/prop_correct,  # Calculate the mean IES for each condition
    n = n()  # Count the number of observations for each condition
  )

# replace NaNs (not a number) and Inf with NAs (missing values)
IES_by_cond_cue_id <- IES_by_cond_cue_id %>%
  mutate(IES = ifelse(is.nan(IES), NA, IES),
         IES = ifelse(IES==Inf, NA, IES),
         meanRT = ifelse(is.nan(meanRT), NA, meanRT))

IES_by_cond_cue<- IES_by_cond_cue_id %>%
  group_by(Condition, req_action, OutValence, Cue) %>%
  summarise(
    mean_IES = mean(IES, na.rm = TRUE),  # Calculate the mean IES for each condition
    sd_IES = sd(IES, na.rm = TRUE),  # Calculate the standard deviation of the IES for each condition
    mean_RT = mean(meanRT, na.rm = TRUE),  # Calculate the mean RT for each condition
    sd_RT = sd(meanRT, na.rm = TRUE),  # Calculate the standard deviation of the RT for each condition
    mean_prop_correct = mean(prop_correct, na.rm = TRUE),  # Calculate the mean prop_correct for each condition
    sd_prop_correct = sd(prop_correct, na.rm = TRUE),  # Calculate the standard deviation of prop_correct for each condition
    n = n()  # Count the number of observations for each condition
  )

print(IES_by_cond_cue) 

```
# exclude outliers (this should be done in a better way, with a clear exclusion threshold)

```{r}

IES_by_cond_cue_id_f <- IES_by_cond_cue_id %>%
  filter(ID != "TRWL0072")
```

# pirate plot - proportion correct
```{r}

library("RColorBrewer")

yarrr::pirateplot(formula = prop_correct ~ Condition + req_action + OutValence,    # DV = evaluation, IV1 = stimulation, IV2 = social_condition, IV3 = gain_loss, 
                  data = IES_by_cond_cue_id,           
                  theme = 3,
                  pal = brewer.pal(3, "Set2"),
                  main = "Performance by context",
                  xlab = "Condition\n Action",
                  ylab = "Proportion of advantegeous choices",
                  bean.f.o = .4, # Bean fill
                  bean.b.o = .2, # Light bean border
                  # point.o = .3, # Points
                  inf.disp = "line",
                  inf.f.o = 0.8, # Inference fill
                  inf.b.o = 0.8, # Inference border
                  inf.f.col = "black", # Inf fill col
                  inf.b.col = "black", # Inf border col
                  avg.line.o = 0, # Average line
                  # bar.f.o = .5, # Bar
                  avg.line.col = "black",  # avg line col
                  #bar.f.col = gray(.8), # bar filling color
                  point.pch = 21,
                  point.bg = "white",
                  point.col = "black",
                  point.cex = .7)

```

# pirate plot - IES
```{r}
yarrr::pirateplot(formula = IES ~ condition + req_action + OutValence,    # DV = evaluation, IV1 = stimulation, IV2 = social_condition, IV3 = gain_loss, 
                  data = IES_by_cond_cue_id_f,           
                  theme = 4,
                  pal = brewer.pal(3, "Set2"),
                  main = "IES by context",
                  ylab = "IInverse Efficiency Score",
                  bean.f.o = .4, # Bean fill
                  bean.b.o = .2, # Light bean border
                  # point.o = .3, # Points
                  inf.disp = "line",
                  inf.f.o = 0.8, # Inference fill
                  inf.b.o = 0.8, # Inference border
                  inf.f.col = "black", # Inf fill col
                  inf.b.col = "black", # Inf border col
                  avg.line.o = 0, # Average line
                  bar.f.o = .5, # Bar
                  avg.line.col = "black") # avg line col
                  #bar.f.col = gray(.8), # bar filling color
                  #point.pch = 21,
                  #point.bg = "white",
                  #point.col = "black",
                  #point.cex = .7)

```